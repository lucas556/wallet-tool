<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>多链私钥/公钥/地址推导（BIP39→BIP32）</title>
<style>
  :root{--bg:#0b1220;--card:#0f1724;--line:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--good:#10b981;--bad:#ef4444}
  html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif}
  .wrap{max-width:1100px;margin:28px auto;padding:0 16px;overflow-x:hidden}
  h1{margin:0 0 8px}
  .muted{color:var(--muted)}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:18px;margin:14px 0;box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .row{display:flex;flex-wrap:wrap;gap:10px;margin:10px 0;align-items:center}
  input,select,button,textarea{
    background:#0c152a;border:1px solid #243250;color:var(--text);
    border-radius:10px;padding:10px 12px
  }
  textarea{width:100%;min-height:68px;resize:vertical}
  button{cursor:pointer} button:hover{filter:brightness(1.08)}
  pre{
    background:#0a1224;border:1px solid #1d2a44;border-radius:10px;
    padding:12px;max-width:100%;white-space:pre-wrap;word-break:break-all;overflow-wrap:anywhere;overflow:auto
  }
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .ok{color:var(--good)} .err{color:var(--bad)}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:900px){ .grid-2{grid-template-columns:1fr} }
  .seg {display:inline-flex;border:1px solid #243250;border-radius:10px;overflow:hidden}
  .seg button{border:0;border-right:1px solid #243250;border-radius:0;background:#0c152a}
  .seg button:last-child{border-right:0}
  .seg button.active{background:#142247;color:#fff}
</style>
</head>
<body>
<div class="wrap">
  <h1>多链私钥 / 公钥 / 地址推导（BIP39 → BIP32，纯前端 / WebCrypto）</h1>
  <div class="muted">可输入助记词或随机生成，然后按链输出私钥、公钥、地址（不显示 xpub/xprv）。</div>

  <!-- 词表静默校验失败时才显示 -->
  <div class="card" id="wl-card" style="display:none">
    <h3>词表校验</h3>
    <div class="row"><span id="wl-tip" class="muted"></span></div>
  </div>

  <div class="card">
    <h3>① 助记词输入 / 生成</h3>

    <div class="row">
      <div class="seg">
        <button id="tab-manual" class="active" type="button">手动输入</button>
        <button id="tab-gen" type="button">随机生成</button>
      </div>

      <label>可选 passphrase：
        <input id="in-pass" placeholder="推荐留空（BIP39 passphrase）"/>
      </label>
      <span id="mn-tip" class="muted"></span>
    </div>

    <!-- 手动输入 -->
    <div id="manual-box">
      <div class="row"><b>助记词：</b><span class="muted">（12 或 24 词，空格分隔）</span></div>
      <textarea id="in-mnemonic" class="mono" placeholder="例如：abandon ability ... zoo"></textarea>
      <div class="row">
        <button id="btn-use" disabled type="button">使用该助记词（校验→推导）</button>
        <span class="muted">会自动做 BIP39 校验（checksum）。</span>
      </div>
    </div>

    <!-- 随机生成 -->
    <div id="gen-box" style="display:none">
      <div class="row">
        <label>词数：
          <select id="sl-words">
            <option value="128">12 词（128-bit）</option>
            <option value="256">24 词（256-bit）</option>
          </select>
        </label>
        <button id="btn-gen" disabled type="button">随机生成助记词（校验→推导）</button>
      </div>
    </div>

    <div id="mnemo-box" style="display:none">
      <div class="row"><b>当前助记词：</b></div>
      <pre id="out-mnemonic" class="mono"></pre>
      <div class="row"><b>Seed (64B hex)：</b></div>
      <pre id="out-seed" class="mono"></pre>
    </div>
  </div>

  <div class="card">
    <h3>② 选择链 → 生成 私钥 / 公钥 / 地址（index 0）</h3>
    <div class="row">
      <label>目标链：
        <select id="sl-chain">
          <option value="BTC">BTC（BIP84，m/84'/0'/0'/0/0，地址 bc1q）</option>
          <option value="ETH">ETH（m/44'/60'/0'/0/0，EIP-55）</option>
          <option value="TRX">TRON（m/44'/195'/0'/0/0，Base58Check）</option>
          <option value="EOS">EOS（m/44'/194'/0'/0/0，EOS 公钥）</option>
        </select>
      </label>
      <button id="btn-derive-chain" disabled type="button">推导</button>
      <span id="ch-tip" class="muted"></span>
    </div>

    <div id="result-box" style="display:none">
      <div class="row" id="path-line"></div>

      <div class="grid-2">
        <div>
          <div class="row"><b>私钥（32B hex）：</b></div>
          <pre id="out-priv" class="mono"></pre>
        </div>
        <div>
          <div class="row"><b>公钥（压缩 33B hex）：</b></div>
          <pre id="out-pubc" class="mono"></pre>
        </div>
      </div>

      <div class="row"><b>公钥（非压缩 65B hex）：</b></div>
      <pre id="out-pubu" class="mono"></pre>

      <div class="row" id="addr-title"></div>
      <pre id="out-addr" class="mono"></pre>
    </div>
  </div>
</div>

<script type="module">
/* ===== 依赖 ===== */
import * as secp from 'https://esm.run/@noble/secp256k1@1.7.1';
import { keccak_256 }  from 'https://esm.sh/@noble/hashes@1.4.0/sha3';
import * as rmd160     from 'https://esm.sh/@noble/hashes@1.4.0/ripemd160';

/* ===== 基础工具 ===== */
const te=new TextEncoder(), td=new TextDecoder();
const $ = id=>document.getElementById(id);
const expectWordlistHash='2f5eed53a4727b4bf8880d8f3f199efc90e58503646d9ff8eff3a2ed3b24dbda';
const curveN = secp.CURVE.n;

function bytesToHex(u8){ let s=''; for(let i=0;i<u8.length;i++) s+=u8[i].toString(16).padStart(2,'0'); return s; }
function hexToBytes(hex){ const h=hex.replace(/^0x/i,''); const out=new Uint8Array(h.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(h.slice(i*2,i*2+2),16); return out; }
function concatBytes(...arrs){ let len=0; for(const a of arrs) len+=a.length; const out=new Uint8Array(len); let off=0; for(const a of arrs){ out.set(a,off); off+=a.length; } return out; }
function ser32(i){ const b=new Uint8Array(4); b[0]=(i>>>24)&255;b[1]=(i>>>16)&255;b[2]=(i>>>8)&255;b[3]=i&255; return b; }

async function wc_sha256(bytes){ const b=bytes instanceof Uint8Array?bytes:new Uint8Array(bytes); const h=await crypto.subtle.digest('SHA-256', b); return new Uint8Array(h); }
async function hash160_async(data){ return rmd160.ripemd160(await wc_sha256(data)); }

/* ===== Base58 & Base58Check ===== */
function base58encode(data){
  const ALPH='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  let x=BigInt('0x'+bytesToHex(data)), out='';
  while(x>0n){ const m=x%58n; out=ALPH[Number(m)]+out; x/=58n; }
  for(let i=0;i<data.length&&data[i]===0;i++) out='1'+out;
  return out||'1';
}
async function base58check_async(payload){
  const s1=await wc_sha256(payload), s2=await wc_sha256(s1);
  return base58encode(concatBytes(payload, s2.slice(0,4)));
}

/* ===== Bech32（v0） for BTC P2WPKH ===== */
const BECH32_CHARSET='qpzry9x8gf2tvdw0s3jn54khce6mua7l';
function bech32_polymod(values){
  const GEN=[0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];
  let chk=1;
  for(const v of values){
    const b=chk>>25; chk=(chk & 0x1ffffff) << 5 ^ v;
    for(let i=0;i<5;i++) if((b>>i)&1) chk^=GEN[i];
  }
  return chk>>>0;
}
function bech32_hrpExpand(hrp){
  const ret=[]; for(let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i)>>5);
  ret.push(0);
  for(let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i)&31);
  return ret;
}
function bech32_createChecksum(hrp,data){
  const values=bech32_hrpExpand(hrp).concat(data).concat([0,0,0,0,0,0]);
  const mod=bech32_polymod(values)^1; const ret=[];
  for(let p=0;p<6;p++) ret.push((mod>>5*(5-p)) & 31);
  return ret;
}
function bech32_encode(hrp,data){
  const combined=data.concat(bech32_createChecksum(hrp,data));
  let out=hrp+'1'; for(const p of combined) out+=BECH32_CHARSET[p];
  return out;
}
function convertBits(data,from,to,pad=true){
  let acc=0,bits=0,ret=[],maxv=(1<<to)-1,maxAcc=(1<<(from+to-1))-1;
  for(const value of data){
    if(value<0||(value>>from)) return null;
    acc=((acc<<from)|value)&maxAcc; bits+=from;
    while(bits>=to){ bits-=to; ret.push((acc>>bits)&maxv); }
  }
  if(pad){ if(bits) ret.push((acc<<(to-bits))&maxv); }
  else if(bits>=from||((acc<<(to-bits))&maxv)) return null;
  return ret;
}
async function btc_p2wpkh_bech32(pubCompressed){
  const h160=await hash160_async(pubCompressed);
  const data=[0].concat(convertBits([...h160],8,5,true));
  return bech32_encode('bc', data);
}

/* ===== BIP39：词表 + checksum 校验 ===== */
let WORDS = null;
async function loadWordlistOnce(){
  if(WORDS) return WORDS;
  const res=await fetch('./english.txt');
  const buf=new Uint8Array(await res.arrayBuffer());
  const got=bytesToHex(await wc_sha256(buf));
  if(got!==expectWordlistHash){
    const card=$('wl-card'), tip=$('wl-tip');
    card.style.display='block';
    tip.innerHTML='<span class="err">english.txt 校验失败：SHA-256 不匹配</span>';
    throw new Error('english.txt hash mismatch');
  }
  WORDS=td.decode(buf).replace(/\r/g,'').trim().split('\n');
  return WORDS;
}
function bytesToBits(u8){ const bits=[]; for(const b of u8) for(let i=7;i>=0;i--) bits.push((b>>i)&1); return bits; }
function bitsToBytes(bits){
  const out=new Uint8Array(Math.ceil(bits.length/8));
  for(let i=0;i<bits.length;i++){
    out[i>>3] |= (bits[i]&1) << (7-(i&7));
  }
  return out;
}
function bitsToIndices(bits, g=11){
  const out=[];
  for(let i=0;i<bits.length;i+=g){
    let v=0; for(let j=0;j<g;j++) v=(v<<1)|(bits[i+j]||0);
    out.push(v);
  }
  return out;
}
function indicesToBits(indices, g=11){
  const bits=[];
  for(const v of indices){
    for(let i=g-1;i>=0;i--) bits.push((v>>i)&1);
  }
  return bits;
}
async function genMnemonic(entBits=128){
  if(!WORDS) await loadWordlistOnce();
  const ENT=entBits, CS=ENT/32;
  const ent=new Uint8Array(ENT/8); crypto.getRandomValues(ent);
  const hash=await wc_sha256(ent);
  const idx=bitsToIndices(bytesToBits(ent).concat(bytesToBits(hash).slice(0,CS)), 11);
  return idx.map(i=>WORDS[i]).join(' ');
}
function normalizeMnemonic(s){
  return (s||'')
    .trim()
    .replace(/\s+/g,' ')
    .normalize('NFKD');
}
function mnemonicToIndices(mnemonic){
  const parts=normalizeMnemonic(mnemonic).split(' ').filter(Boolean);
  if(parts.length!==12 && parts.length!==15 && parts.length!==18 && parts.length!==21 && parts.length!==24){
    throw new Error('助记词数量必须是 12/15/18/21/24');
  }
  const map=new Map();
  for(let i=0;i<WORDS.length;i++) map.set(WORDS[i], i);
  const idx=[];
  for(const w of parts){
    const v=map.get(w);
    if(v===undefined) throw new Error('词表中不存在：'+w);
    idx.push(v);
  }
  return idx;
}
async function bip39Check(mnemonic){
  if(!WORDS) await loadWordlistOnce();
  const idx = mnemonicToIndices(mnemonic);
  const bits = indicesToBits(idx, 11);

  const ENT = Math.floor(bits.length * 32 / 33);
  const CS  = bits.length - ENT;

  if(ENT % 32 !== 0) throw new Error('非法助记词长度');
  const entBits = bits.slice(0, ENT);
  const csBits  = bits.slice(ENT);

  const entBytes = bitsToBytes(entBits);
  const hash = await wc_sha256(entBytes);
  const hashBits = bytesToBits(hash).slice(0, CS);

  for(let i=0;i<CS;i++){
    if(csBits[i] !== hashBits[i]) return false;
  }
  return true;
}
async function pbkdf2_sha512(pwdBytes,saltBytes,iter,dkLen){
  const key=await crypto.subtle.importKey('raw', pwdBytes, 'PBKDF2', false, ['deriveBits']);
  const bits=await crypto.subtle.deriveBits({ name:'PBKDF2', hash:'SHA-512', salt:saltBytes, iterations:iter }, key, dkLen*8);
  return new Uint8Array(bits);
}
async function mnemonicToSeed(mnemonic, passphrase){
  const salt=te.encode('mnemonic'+(passphrase||'')).buffer;
  const pwd =te.encode(mnemonic).buffer;
  return pbkdf2_sha512(new Uint8Array(pwd), new Uint8Array(salt), 2048, 64);
}

/* ===== HMAC-SHA512 ===== */
async function hmacSHA512(keyBytes,dataBytes){
  const key=await crypto.subtle.importKey('raw', keyBytes, { name:'HMAC', hash:'SHA-512' }, false, ['sign']);
  const sig=await crypto.subtle.sign('HMAC', key, dataBytes);
  return new Uint8Array(sig);
}

/* ===== BIP32（仅保留私钥派生节点，不序列化 xpub/xprv） ===== */
async function bip32RootFromSeed(seed){
  const I=await hmacSHA512(te.encode('Bitcoin seed'), seed);
  const IL=I.slice(0,32), IR=I.slice(32);
  const k=BigInt('0x'+bytesToHex(IL));
  if(k===0n||k>=curveN) throw new Error('Invalid master key');
  const key32=IL, chain=IR, depth=0;
  const pub=secp.getPublicKey(key32,true);
  return { key:key32, chain, pub, depth };
}
async function CKDpriv(node,index,hardened){
  const { key, chain, depth }=node;
  const idx=hardened?(index|0x80000000):index;
  const data=hardened?concatBytes(new Uint8Array([0]), key, ser32(idx))
                     :concatBytes(secp.getPublicKey(key,true), ser32(idx));
  const I=await hmacSHA512(chain,data);
  const IL=I.slice(0,32), IR=I.slice(32);
  const ki=(BigInt('0x'+bytesToHex(IL))+BigInt('0x'+bytesToHex(key)))%curveN;
  if(ki===0n) throw new Error('Invalid child key');
  const keyChild=hexToBytes(ki.toString(16).padStart(64,'0'));
  const pubChild=secp.getPublicKey(keyChild,true);
  return { key:keyChild, chain:IR, pub:pubChild, depth:depth+1 };
}

/* ===== 各链地址工具 ===== */
function ethChecksumFromPub(pubCompressed){
  const uncompressed=secp.Point.fromHex(pubCompressed).toRawBytes(false);
  const body=uncompressed.slice(1);
  const h=keccak_256(body);
  const addr=h.slice(12);
  const lower=bytesToHex(addr).toLowerCase();
  const h2=bytesToHex(keccak_256(te.encode(lower)));
  let out='0x';
  for(let i=0;i<lower.length;i++){
    out += (parseInt(h2[i],16)>=8) ? lower[i].toUpperCase() : lower[i];
  }
  return out;
}
async function tronAddressFromPub(pubCompressed){
  const uncompressed=secp.Point.fromHex(pubCompressed).toRawBytes(false);
  const body=uncompressed.slice(1);
  const hash=keccak_256(body);
  const addr=hash.slice(12);
  return base58check_async(concatBytes(new Uint8Array([0x41]), addr));
}
async function eosLegacyPub(pubCompressed){
  const checksum=rmd160.ripemd160(pubCompressed).slice(0,4);
  return 'EOS' + base58encode(concatBytes(pubCompressed, checksum));
}

/* ===== 全局状态 ===== */
let gMnemonic=null, gSeed=null, gRoot=null;

function setTab(which){
  $('tab-manual').classList.toggle('active', which==='manual');
  $('tab-gen').classList.toggle('active', which==='gen');
  $('manual-box').style.display = which==='manual' ? 'block' : 'none';
  $('gen-box').style.display    = which==='gen' ? 'block' : 'none';
  $('mn-tip').textContent='';
}

/* 静默加载词表并解锁按钮 */
document.addEventListener('DOMContentLoaded', async ()=>{
  try{
    await loadWordlistOnce();
    $('btn-gen').disabled=false;
    $('btn-use').disabled=false;
    $('ch-tip').textContent='先输入/生成助记词，再推导。';
  }catch(e){
    const card=$('wl-card'), tip=$('wl-tip');
    card.style.display='block';
    tip.innerHTML='<span class="err">词表加载失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
});

/* tab 切换 */
$('tab-manual').addEventListener('click', ()=>setTab('manual'));
$('tab-gen').addEventListener('click', ()=>setTab('gen'));

/* 公共：使用 mnemonic 推导 seed/root */
async function useMnemonicAndDerive(mnemonic){
  const tip=$('mn-tip');
  tip.textContent='校验中...';
  const pass=($('in-pass').value||'').normalize('NFKD');

  const ok = await bip39Check(mnemonic);
  if(!ok) throw new Error('助记词 checksum 校验失败（不是合法 BIP39 助记词）');

  tip.textContent='推导 Seed...';
  const seed=await mnemonicToSeed(mnemonic, pass);

  tip.textContent='推导 Root...';
  const root=await bip32RootFromSeed(seed);

  gMnemonic = normalizeMnemonic(mnemonic);
  gSeed = seed;
  gRoot = root;

  $('out-mnemonic').textContent=gMnemonic;
  $('out-seed').textContent=bytesToHex(seed);
  $('mnemo-box').style.display='block';

  $('btn-derive-chain').disabled=false;
  $('ch-tip').textContent='已就绪。选择链并推导。';
  tip.innerHTML='<span class="ok">OK</span>';
}

/* 手动输入：使用该助记词 */
$('btn-use').addEventListener('click', async ()=>{
  try{
    $('result-box').style.display='none';
    const mnemonic = $('in-mnemonic').value;
    if(!mnemonic.trim()) throw new Error('请输入助记词');
    await useMnemonicAndDerive(mnemonic);
  }catch(e){
    $('mn-tip').innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
});

/* 随机生成：生成并使用 */
$('btn-gen').addEventListener('click', async ()=>{
  try{
    $('result-box').style.display='none';
    const ent=parseInt(($('sl-words').value||'128'),10);
    const mnemonic=await genMnemonic(ent);
    await useMnemonicAndDerive(mnemonic);
  }catch(e){
    $('mn-tip').innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
});

/* 推导：按链输出 私钥/公钥/地址（index 0） */
$('btn-derive-chain').addEventListener('click', async ()=>{
  const chain = $('sl-chain').value;
  const tip = $('ch-tip');

  try{
    if(!gRoot) throw new Error('请先输入或生成助记词');

    $('result-box').style.display='none';
    $('out-priv').textContent='';
    $('out-pubc').textContent='';
    $('out-pubu').textContent='';
    $('out-addr').textContent='';
    $('addr-title').textContent='';
    $('path-line').textContent='';
    tip.textContent='推导中...';

    // 统一推到最终地址节点（含最后的 /0 ）
    let n = gRoot;

    if(chain==='BTC'){
      // m/84'/0'/0'/0/0
      n=await CKDpriv(n,84,true);
      n=await CKDpriv(n,0,true);
      n=await CKDpriv(n,0,true);
      n=await CKDpriv(n,0,false);
      n=await CKDpriv(n,0,false);

      const priv = n.key;
      const pubC = secp.getPublicKey(priv, true);
      const pubU = secp.getPublicKey(priv, false);
      const addr = await btc_p2wpkh_bech32(pubC);

      $('path-line').innerHTML = `<b>路径：</b> <span class="mono">m/84'/0'/0'/0/0</span>`;
      $('addr-title').innerHTML = `<b>地址（bech32）：</b>`;
      $('out-priv').textContent = bytesToHex(priv);
      $('out-pubc').textContent = bytesToHex(pubC);
      $('out-pubu').textContent = bytesToHex(pubU);
      $('out-addr').textContent = addr;
    }
    else if(chain==='ETH'){
      // m/44'/60'/0'/0/0
      n=await CKDpriv(n,44,true);
      n=await CKDpriv(n,60,true);
      n=await CKDpriv(n,0,true);
      n=await CKDpriv(n,0,false);
      n=await CKDpriv(n,0,false);

      const priv = n.key;
      const pubC = secp.getPublicKey(priv, true);
      const pubU = secp.getPublicKey(priv, false);
      const addr = ethChecksumFromPub(pubC);

      $('path-line').innerHTML = `<b>路径：</b> <span class="mono">m/44'/60'/0'/0/0</span>`;
      $('addr-title').innerHTML = `<b>地址（EIP-55）：</b>`;
      $('out-priv').textContent = bytesToHex(priv);
      $('out-pubc').textContent = bytesToHex(pubC);
      $('out-pubu').textContent = bytesToHex(pubU);
      $('out-addr').textContent = addr;
    }
    else if(chain==='TRX'){
      // m/44'/195'/0'/0/0
      n=await CKDpriv(n,44,true);
      n=await CKDpriv(n,195,true);
      n=await CKDpriv(n,0,true);
      n=await CKDpriv(n,0,false);
      n=await CKDpriv(n,0,false);

      const priv = n.key;
      const pubC = secp.getPublicKey(priv, true);
      const pubU = secp.getPublicKey(priv, false);
      const addr = await tronAddressFromPub(pubC);

      $('path-line').innerHTML = `<b>路径：</b> <span class="mono">m/44'/195'/0'/0/0</span>`;
      $('addr-title').innerHTML = `<b>地址（TRON Base58Check）：</b>`;
      $('out-priv').textContent = bytesToHex(priv);
      $('out-pubc').textContent = bytesToHex(pubC);
      $('out-pubu').textContent = bytesToHex(pubU);
      $('out-addr').textContent = addr;
    }
    else if(chain==='EOS'){
      // m/44'/194'/0'/0/0  → 输出 EOS 公钥（传统 EOS...）
      n=await CKDpriv(n,44,true);
      n=await CKDpriv(n,194,true);
      n=await CKDpriv(n,0,true);
      n=await CKDpriv(n,0,false);
      n=await CKDpriv(n,0,false);

      const priv = n.key;
      const pubC = secp.getPublicKey(priv, true);
      const pubU = secp.getPublicKey(priv, false);
      const pubEOS = await eosLegacyPub(pubC);

      $('path-line').innerHTML = `<b>路径：</b> <span class="mono">m/44'/194'/0'/0/0</span>`;
      $('addr-title').innerHTML = `<b>EOS 公钥（EOS...）：</b>`;
      $('out-priv').textContent = bytesToHex(priv);
      $('out-pubc').textContent = bytesToHex(pubC);
      $('out-pubu').textContent = bytesToHex(pubU);
      $('out-addr').textContent = pubEOS;
    }

    $('result-box').style.display='block';
    tip.innerHTML='<span class="ok">完成</span>';
  }catch(e){
    tip.innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
});
</script>
</body>
</html>
